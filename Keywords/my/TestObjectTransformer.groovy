package my

import com.kms.katalon.core.annotation.Keyword
import com.kms.katalon.core.logging.KeywordLogger
import com.kms.katalon.core.model.FailureHandling
import com.kms.katalon.core.testobject.TestObject
import com.kms.katalon.core.testobject.TestObjectProperty
import com.kms.katalon.core.testobject.TestObjectXpath
import com.kms.katalon.core.testobject.SelectorMethod
import com.kms.katalon.core.util.KeywordUtil

/**
 * 
 * @author kazurayam
 *
 */
class TestObjectTransformer {

	private static KeywordLogger logger = KeywordUtil.logInfo()

	/**
	 * This accepts a test object with xpath in the format of
	 *     <code>//button[@id="staticId1:dynamicId:staticId2"]/span</code>
	 * 
	 * then it transform the expression into another expression of
	 *     <code>//button[starts-with(@id,"staticId1") and (substring(@id,string-length(@id)-string-length("staticId2")+1)="staticId2")]/span<code>
	 * 
	 * then it generates a TestObject instance with the XPath generated above, 
	 * 
	 * finally it returns the new TestObject
	 * 
	 * Michal.Pachucki wanted this
	 * 
	 * @param testObject a TestObject with XPath in the above mentioned format, which was generated by WebRecorder possibly
	 * @returns new TestObject
	 */
	@Keyword
	static TestObject toMichalPachuckiXpath(TestObject testObject, FailureHandling flowControl) {
		String xpath = ''
		try {
			return transformTestObject(testObject, 
				{ expr -> 
					return expr
				})
		} catch (Exception e) {
			stepFailed("failed to transform xpath: ${xpath}", flowControl)
		}
	}

	/**
	 * 
	 * @param source TestObject instance as source. It should have Selector Method=XPATH or BASIC. CSS is not supported.
	 * @param logic a Groovy Closure which transforms input xpath expression into another xpath expression
	 */
	private static TestObject transformTestObject(TestObject source, Closure logic) {
		TestObject newTO = new TestObject(source.getObjectId())
		if (source.getSelectorMethod() == SelectorMethod.XPATH) {
			newTO.setSelectorMethod(SelectorMethod.XPATH)
			List<TestObjectXpath> toxList = new ArrayList<>()
			for (TestObjectXpath tox : source.getActiveXpaths()) {
				TestObjectXpath newTox = new TestObjectXpath()
				newTox.setName(tox.getName())
				// xpath expression is transformed by the logic 
				newTox.setValue(logic.call(tox.getValue()))
				toxList.add(newTox)
			}
			newTO.setXpaths(toxList)
		} else if (source.getSelectorMethod() == SelectorMethod.BASIC) {
			newTO.setSelectorMethod(SelectorMethod.BASIC)
			List<TestObjectProperty> topList = new ArrayList<>()
			for (TestObjectProperty top : source.getActiveProperties()) {
				TestObjectProperty newTop = new TestObjectProperty()
				newTop.setName(top.getName())
				newTop.setCondition(top.getCondition())
				newTop.setValue(logic(top.getValue()))
				topList.add(newTop)
			}
			newTO.setProperties(topList)
		} else if (source.getSelectorMethod() == SelectorMethod.CSS) {
			throw new UnsupportedOperationException("SelectionMethod.CSS is not yet supported")
		} else {
			throw new RuntimeException("unknow selectionMethod")
		}
		//newTestObject.setSelectorMethod(SelectorMethod.BASIC)
		return newTO
	}

	static def stepFailed(String message, FailureHandling flowControl) {
		if (flowControl == FailureHandling.OPTIONAL) {
			println "#stepFailed('${message}',FailureHandling.OPTIONAL)"
			logger.logWarning(message)
		} else if (flowControl == FailureHandling.CONTINUE_ON_FAILURE) {
			println "#stepFailed('${message}',FailureHandling.CONTINUE_ON_FAILURE)"
			logger.logFailed(message)
			KeywordUtil.markFailed(message)
		} else {
			// in the case where flowControl == FailureHandling.STOP_ON_FAILURE
			println "#stepFailed('${message}',FailureHandling.STOP_ON_FAILURE)"
			logger.logFailed(message)
			KeywordUtil.markFailedAndStop(message)
		}
	}
}